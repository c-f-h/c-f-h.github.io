<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Preparing the Data | cfh::blog</title>
<meta name="keywords" content="Math, C&#43;&#43;, ML">
<meta name="description" content="With the triangle self-intersection algorithm ready to go, we
can start gathering the training data for our machine learning setup. But first we have to think about how
exactly we want to represent it.
Canonical triangles
The curved triangles we work with are specified by six 3D vectors, so that
would mean 18 floating point numbers as our input data.
But an important insight is that whether a triangle intersects itself doesn&rsquo;t change when we rotate it, translate it,
or uniformly scale it&mdash;it&rsquo;s well known that affine transformations of spline control points result in affine transformations of the surface itself.">
<meta name="author" content="cfh">
<link rel="canonical" href="https://c-f-h.github.io/post/preparing-the-data/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5c33e5d3f9279b49f845e940304f13c1593579964c46446a0b14ec2d6bdd02c1.css" integrity="sha256-XDPl0/knm0n4RelAME8TwVk1eZZMRkRqCxTsLWvdAsE=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://c-f-h.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://c-f-h.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://c-f-h.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://c-f-h.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://c-f-h.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://c-f-h.github.io/post/preparing-the-data/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><head>
  
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)']]                  
    },
    loader:{
      load: ['ui/safe']
    },
  };
</script>
  
  
  
</head><meta property="og:url" content="https://c-f-h.github.io/post/preparing-the-data/">
  <meta property="og:site_name" content="cfh::blog">
  <meta property="og:title" content="Preparing the Data">
  <meta property="og:description" content="With the triangle self-intersection algorithm ready to go, we can start gathering the training data for our machine learning setup. But first we have to think about how exactly we want to represent it.
Canonical triangles The curved triangles we work with are specified by six 3D vectors, so that would mean 18 floating point numbers as our input data. But an important insight is that whether a triangle intersects itself doesn’t change when we rotate it, translate it, or uniformly scale it—it’s well known that affine transformations of spline control points result in affine transformations of the surface itself.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2025-04-09T20:57:38+02:00">
    <meta property="article:modified_time" content="2025-04-09T20:57:38+02:00">
    <meta property="article:tag" content="Math">
    <meta property="article:tag" content="C&#43;&#43;">
    <meta property="article:tag" content="ML">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Preparing the Data">
<meta name="twitter:description" content="With the triangle self-intersection algorithm ready to go, we
can start gathering the training data for our machine learning setup. But first we have to think about how
exactly we want to represent it.
Canonical triangles
The curved triangles we work with are specified by six 3D vectors, so that
would mean 18 floating point numbers as our input data.
But an important insight is that whether a triangle intersects itself doesn&rsquo;t change when we rotate it, translate it,
or uniformly scale it&mdash;it&rsquo;s well known that affine transformations of spline control points result in affine transformations of the surface itself.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://c-f-h.github.io/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Preparing the Data",
      "item": "https://c-f-h.github.io/post/preparing-the-data/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Preparing the Data",
  "name": "Preparing the Data",
  "description": "With the triangle self-intersection algorithm ready to go, we can start gathering the training data for our machine learning setup. But first we have to think about how exactly we want to represent it.\nCanonical triangles The curved triangles we work with are specified by six 3D vectors, so that would mean 18 floating point numbers as our input data. But an important insight is that whether a triangle intersects itself doesn\u0026rsquo;t change when we rotate it, translate it, or uniformly scale it\u0026mdash;it\u0026rsquo;s well known that affine transformations of spline control points result in affine transformations of the surface itself.\n",
  "keywords": [
    "Math", "C++", "ML"
  ],
  "articleBody": "With the triangle self-intersection algorithm ready to go, we can start gathering the training data for our machine learning setup. But first we have to think about how exactly we want to represent it.\nCanonical triangles The curved triangles we work with are specified by six 3D vectors, so that would mean 18 floating point numbers as our input data. But an important insight is that whether a triangle intersects itself doesn’t change when we rotate it, translate it, or uniformly scale it—it’s well known that affine transformations of spline control points result in affine transformations of the surface itself.\nSo we can transform any triangle into the following canonical form without changing the intersection property: Put the first vertex at \\((0,0,0)\\), the second at \\((1,0,0)\\), and the third at \\((x,y,0)\\) with \\(y\u003e0\\). The remaining three edge control points are transformed alongside, but we don’t put any special constraints on them. This means that the only relevant input data for such a canonicalized triangle are the three edge control points plus the \\(x\\) and \\(y\\) coordinates of the third vertex. That’s down to 11 floats from 18 originally, a big reduction!\nHow do we implement this transformation? First we subtract \\(P_{200}\\) from all six vectors. Then we rotate the triangle such that the first axis lies along the x axis and the second axis lies in the (x,y)-plane. Finally we scale the triangle such that the transformed \\(P_{020}\\) lies at \\((1,0,0)\\).\nThe rotation matrix is the slightly tricky part, but with some basic linear algebra it’s pretty straightforward. A good thing to remember is that if you have three unit vectors which follow the right-hand rule, you can stick them as column vectors into a \\(3\\times3\\) matrix and get a rotation matrix which rotates the x, y and z axes into that new configuration given by your three vectors. And a second useful fact is that the inverse of a rotation matrix is just its transpose. So that means if you put your three vectors into the matrix as row vectors instead, you get a matrix which rotates your three chosen vectors back to the standard x, y and z axes.\nHere’s the C++ function which implements the transformation to a canonical triangle.\nCurvedTriangle CurvedTriangle::canonicalize() const { Eigen::Vector3d u = P020 - P200; Eigen::Vector3d v = P002 - P200; Eigen::Vector3d newX = u / u.norm(); // Normalized vector along the new x-axis Eigen::Vector3d w = u.cross(v); // Vector perpendicular to the triangle plane Eigen::Vector3d newZ = w / w.norm(); // Normalized vector along the new z-axis // Define the new y-axis using the cross product to ensure right-handed system Eigen::Vector3d newY = newZ.cross(newX); // Construct the inverse rotation matrix which rotates (newX, newY, newZ) // into the standard coordinate system. Eigen::Matrix3d R_inv; R_inv.row(0) = newX; R_inv.row(1) = newY; R_inv.row(2) = newZ; // Translate and rotate all six vectors std::array\u003cEigen::Vector3d, 6\u003e result{ R_inv * (P200 - P200), // = (0, 0, 0) R_inv * (P020 - P200), // = (u_norm, 0, 0) R_inv * (P002 - P200), // = (x, y, 0) with y \u003e 0 R_inv * (P110 - P200), R_inv * (P101 - P200), R_inv * (P011 - P200), }; // Scale to unit length for first axis const double scale = result[1][0]; for (auto\u0026\u0026 v : result) v /= scale; return CurvedTriangle{result}; } The data labels Obviously, at minimum we just need a single bit to tell us if each canonicalized triangle does self-intersect or not. The format I used in practice has a bit more detail because I planned to give more structured information to the ML algorithm. Although at first we’ll only train a simple binary classifier, making this data format overkill, having it available could later allow us to train a more nuanced representation.\nThe idea is to provide a kind of “heatmap” in the form of a 16x16 bitmap representing the rasterized (u,v)-space. It has bits set where the intersection curve, if one does exist, lies in the parameter domain. Both the \\((u_1,v_1)\\) and the \\((u_2,v_2)\\) components are rasterized into the same bitmap to keep the data small. The rasterization is implemented by linearly interpolating between each pair of curve points and mapping into the discretized (u,v)-space.\nA 16x16 bitmap showing the location of an intersection curve in parameter space. The upper right half is always empty, but for simplicity we store it anyway.\nSince each pixel is either 0 or 1, we can compress the 256 pixels of such a bitmap into 32 bytes. To convert this to a single 0/1 label, we simply check if the entire bitmap is 0 or there are any pixels lit.\nThe binary file format That’s all we need. To populate our dataset, we generate six random vectors with coordinates uniformly chosen in \\([-1,1]\\), canonicalize them, check for intersections, and compute the bitmap of the intersection curve. Each sample is written to a binary file that has eleven 32-bit floats (44 bytes) for the canonicalized triangle coordinates plus 32 bytes for the bitmap for each record, for a total of 76 bytes per record. A simple binary format like this saves space and is easy and quick to read and write in both C++ and Python.\nI multithreaded the generation of these binary data files to speed things up and collected the results in files triangles.000, triangles.001, and so on, with each file containing 10,000 samples or 760,000 bytes. Currently I have 90 of these files, giving us 900,000 samples to train with; later we’ll augment our data set further. All training samples are then concatenated into triangles.dat. I also generated another 20,000 samples for the validation set, triangles.val.\nSurprisingly, the simple random triangle generation leads to a data set that is very well balanced between intersecting and non-intersecting triangles: of the 20,000 validation samples, 10,191 are positives.\nWith the input data set up, we can finally set up a model and start training!\n",
  "wordCount" : "987",
  "inLanguage": "en",
  "datePublished": "2025-04-09T20:57:38+02:00",
  "dateModified": "2025-04-09T20:57:38+02:00",
  "author":{
    "@type": "Person",
    "name": "cfh"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://c-f-h.github.io/post/preparing-the-data/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "cfh::blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://c-f-h.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://c-f-h.github.io/" accesskey="h" title="cfh::blog (Alt + H)">cfh::blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://c-f-h.github.io/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
            <li>
                <a href="https://c-f-h.github.io/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://c-f-h.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://c-f-h.github.io/post/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Preparing the Data
    </h1>

  
    <div class="series-info">
      <div class="series-name">
        Series: <a href="/categories/the-triangle-project" onclick="document.getElementById('timeline-card').classList.toggle('collapsed'); return false;">The Triangle Project</a>
        (Part 4 of 5)
      </div>
      <nav class="series-navigation"><a href="/post/refining-intersections/" title="Previous: Getting Accurate Intersections with Gauss-Newton">
            <span class="arrow">←</span> Previous
          </a><a href="/post/training-the-first-model/" title="Next: Training the First Model">
            Next <span class="arrow">→</span>
          </a></nav>
    </div>
    <div class="timeline-card collapsed" id="timeline-card">
    <div class="timeline">
      <div class="item">
          <div class="item-title">
            1.&nbsp;<a href="/post/the-triangle-problem/">The Curved Triangle Problem</a></div>
          <div class="item-date">April 6, 2025</div>
        </div><div class="item">
          <div class="item-title">
            2.&nbsp;<a href="/post/computing-intersections/">Computing Self-Intersections, the Geometric Way</a></div>
          <div class="item-date">April 7, 2025</div>
        </div><div class="item">
          <div class="item-title">
            3.&nbsp;<a href="/post/refining-intersections/">Getting Accurate Intersections with Gauss-Newton</a></div>
          <div class="item-date">April 8, 2025</div>
        </div><div class="item current">
          <div class="item-title">
            4.&nbsp;Preparing the Data</div>
          <div class="item-date">April 9, 2025 • You are here</div>
        </div><div class="item inactive">
          <div class="item-title">
            5.&nbsp;<a href="/post/training-the-first-model/">Training the First Model</a></div>
          <div class="item-date">April 10, 2025</div>
        </div>
    </div>
  </div>
  


    <div class="post-meta"><span title='2025-04-09 20:57:38 +0200 CEST'>April 9, 2025</span>&nbsp;·&nbsp;cfh

</div>
  </header> 
  <div class="post-content"><p>With the <a href="/post/refining-intersections/">triangle self-intersection algorithm</a> ready to go, we
can start gathering the training data for our machine learning setup. But first we have to think about how
exactly we want to represent it.</p>
<h2 id="canonical-triangles">Canonical triangles<a hidden class="anchor" aria-hidden="true" href="#canonical-triangles">#</a></h2>
<p>The <a href="/post/the-triangle-problem/">curved triangles</a> we work with are specified by six 3D vectors, so that
would mean 18 floating point numbers as our input data.
But an important insight is that whether a triangle intersects itself doesn&rsquo;t change when we rotate it, translate it,
or uniformly scale it&mdash;it&rsquo;s well known that affine transformations of spline control points result in affine transformations of the surface itself.</p>
<p>So we can transform any triangle into the following canonical form without changing the intersection property:
Put the first vertex at \((0,0,0)\), the second at \((1,0,0)\), and the third at \((x,y,0)\) with \(y>0\).
The remaining three edge control points are transformed alongside, but we don&rsquo;t put any special constraints on them.
This means that the only relevant input data for such a canonicalized triangle are the three edge control points
plus the \(x\) and \(y\) coordinates of the third vertex. That&rsquo;s down to 11 floats from 18 originally, a big reduction!</p>
<p>How do we implement this transformation? First we subtract \(P_{200}\) from all six vectors. Then we rotate the triangle such
that the first axis lies along the x axis and the second axis lies in the (x,y)-plane.
Finally we scale the triangle such that the transformed \(P_{020}\) lies at \((1,0,0)\).</p>
<p>The rotation matrix is the slightly tricky part, but with some basic linear algebra it&rsquo;s pretty straightforward.
A good thing to remember is that if you have three unit vectors which follow the
<a href="https://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>,
you can stick them as column vectors into a \(3\times3\) matrix and get a rotation matrix which rotates the
x, y and z axes into that new configuration
given by your three vectors. And a second useful fact is that the inverse of a rotation matrix is just its transpose.
So that means if you put your three vectors into the matrix as row vectors instead, you get a matrix which rotates
your three chosen vectors back to the standard x, y and z axes.</p>
<p>Here&rsquo;s the C++ function which implements the transformation to a canonical triangle.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">CurvedTriangle</span> <span class="n">CurvedTriangle</span><span class="o">::</span><span class="n">canonicalize</span><span class="p">()</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">u</span> <span class="o">=</span> <span class="n">P020</span> <span class="o">-</span> <span class="n">P200</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">v</span> <span class="o">=</span> <span class="n">P002</span> <span class="o">-</span> <span class="n">P200</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">newX</span> <span class="o">=</span> <span class="n">u</span> <span class="o">/</span> <span class="n">u</span><span class="p">.</span><span class="n">norm</span><span class="p">();</span>    <span class="c1">// Normalized vector along the new x-axis
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">w</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>         <span class="c1">// Vector perpendicular to the triangle plane
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">newZ</span> <span class="o">=</span> <span class="n">w</span> <span class="o">/</span> <span class="n">w</span><span class="p">.</span><span class="n">norm</span><span class="p">();</span>    <span class="c1">// Normalized vector along the new z-axis
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Define the new y-axis using the cross product to ensure right-handed system
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">newY</span> <span class="o">=</span> <span class="n">newZ</span><span class="p">.</span><span class="n">cross</span><span class="p">(</span><span class="n">newX</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Construct the inverse rotation matrix which rotates (newX, newY, newZ)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// into the standard coordinate system.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3d</span> <span class="n">R_inv</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">R_inv</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">newX</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">R_inv</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">newY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">R_inv</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">newZ</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Translate and rotate all six vectors
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">R_inv</span> <span class="o">*</span> <span class="p">(</span><span class="n">P200</span> <span class="o">-</span> <span class="n">P200</span><span class="p">),</span> <span class="c1">// = (0, 0, 0)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">R_inv</span> <span class="o">*</span> <span class="p">(</span><span class="n">P020</span> <span class="o">-</span> <span class="n">P200</span><span class="p">),</span> <span class="c1">// = (u_norm, 0, 0)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">R_inv</span> <span class="o">*</span> <span class="p">(</span><span class="n">P002</span> <span class="o">-</span> <span class="n">P200</span><span class="p">),</span> <span class="c1">// = (x, y, 0) with y &gt; 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">R_inv</span> <span class="o">*</span> <span class="p">(</span><span class="n">P110</span> <span class="o">-</span> <span class="n">P200</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">R_inv</span> <span class="o">*</span> <span class="p">(</span><span class="n">P101</span> <span class="o">-</span> <span class="n">P200</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">R_inv</span> <span class="o">*</span> <span class="p">(</span><span class="n">P011</span> <span class="o">-</span> <span class="n">P200</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Scale to unit length for first axis
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="kt">double</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="nl">v</span> <span class="p">:</span> <span class="n">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">v</span> <span class="o">/=</span> <span class="n">scale</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">CurvedTriangle</span><span class="p">{</span><span class="n">result</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="the-data-labels">The data labels<a hidden class="anchor" aria-hidden="true" href="#the-data-labels">#</a></h2>
<p>Obviously, at minimum we just need a single bit to tell us if each canonicalized triangle does self-intersect or not.
The format I used in practice has a bit more detail because I planned to give more structured information to the
ML algorithm. Although at first we&rsquo;ll only train a simple binary classifier, making this data format overkill,
having it available could later allow us to train a more nuanced representation.</p>
<p>The idea is to provide a kind of &ldquo;heatmap&rdquo; in the form of a 16x16 bitmap representing the rasterized (u,v)-space.
It has bits set where the intersection curve, if one does exist, lies in the parameter domain.
Both the \((u_1,v_1)\) and the \((u_2,v_2)\) components are rasterized into the same bitmap to keep the data small.
The rasterization is implemented by linearly interpolating between each pair of curve points and mapping into
the discretized (u,v)-space.</p>




<figure id="diagram-2">
  
    <svg class="diagram" width="256" height="265"  xmlns="http://www.w3.org/2000/svg" version="1.1">
      <g transform='translate(8,16)'>
<circle cx='0' cy='0' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='0' cy='16' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='0' cy='32' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='0' cy='48' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='0' cy='64' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='0' cy='80' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='0' cy='96' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='0' cy='112' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='0' cy='128' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='0' cy='144' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='0' cy='160' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='0' cy='176' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='0' cy='192' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='0' cy='208' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='0' cy='224' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='0' cy='240' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='16' cy='16' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='16' cy='32' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='16' cy='48' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='16' cy='64' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='16' cy='80' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='16' cy='96' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='16' cy='112' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='16' cy='128' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='16' cy='144' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='16' cy='160' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='16' cy='176' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='16' cy='192' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='16' cy='208' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='16' cy='224' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='16' cy='240' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='32' cy='32' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='32' cy='48' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='32' cy='64' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='32' cy='80' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='32' cy='96' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='32' cy='112' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='32' cy='128' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='32' cy='144' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='32' cy='160' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='32' cy='176' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='32' cy='192' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='32' cy='208' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='32' cy='224' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='32' cy='240' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='48' cy='48' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='48' cy='64' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='48' cy='80' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='48' cy='96' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='48' cy='112' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='48' cy='128' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='48' cy='144' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='48' cy='160' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='48' cy='176' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='48' cy='192' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='48' cy='208' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='48' cy='224' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='48' cy='240' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='64' cy='64' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='64' cy='80' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='64' cy='96' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='64' cy='112' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='64' cy='128' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='64' cy='144' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='64' cy='160' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='64' cy='176' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='64' cy='192' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='64' cy='208' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='64' cy='224' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='64' cy='240' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='80' cy='80' r='6' stroke='currentColor' fill='currentColor'></circle>
<circle cx='80' cy='96' r='6' stroke='currentColor' fill='currentColor'></circle>
<circle cx='80' cy='112' r='6' stroke='currentColor' fill='currentColor'></circle>
<circle cx='80' cy='128' r='6' stroke='currentColor' fill='currentColor'></circle>
<circle cx='80' cy='144' r='6' stroke='currentColor' fill='currentColor'></circle>
<circle cx='80' cy='160' r='6' stroke='currentColor' fill='currentColor'></circle>
<circle cx='80' cy='176' r='6' stroke='currentColor' fill='currentColor'></circle>
<circle cx='80' cy='192' r='6' stroke='currentColor' fill='currentColor'></circle>
<circle cx='80' cy='208' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='80' cy='224' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='80' cy='240' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='96' cy='96' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='96' cy='112' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='96' cy='128' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='96' cy='144' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='96' cy='160' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='96' cy='176' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='96' cy='192' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='96' cy='208' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='96' cy='224' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='96' cy='240' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='112' cy='112' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='112' cy='128' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='112' cy='144' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='112' cy='160' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='112' cy='176' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='112' cy='192' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='112' cy='208' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='112' cy='224' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='112' cy='240' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='128' cy='128' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='128' cy='144' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='128' cy='160' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='128' cy='176' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='128' cy='192' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='128' cy='208' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='128' cy='224' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='128' cy='240' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='144' cy='144' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='144' cy='160' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='144' cy='176' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='144' cy='192' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='144' cy='208' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='144' cy='224' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='144' cy='240' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='160' cy='160' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='160' cy='176' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='160' cy='192' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='160' cy='208' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='160' cy='224' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='160' cy='240' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='176' cy='176' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='176' cy='192' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='176' cy='208' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='176' cy='224' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='176' cy='240' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='192' cy='192' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='192' cy='208' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='192' cy='224' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='192' cy='240' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='208' cy='208' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='208' cy='224' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='208' cy='240' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='224' cy='224' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='224' cy='240' r='6' stroke='currentColor' fill='#fff'></circle>
<circle cx='240' cy='240' r='6' stroke='currentColor' fill='#fff'></circle>
</g>

    </svg>
  
  <figcaption><p>A 16x16 bitmap showing the location of an intersection curve in parameter space. The upper right half is always empty, but for simplicity we store it anyway.</p></figcaption>
</figure><p>Since each pixel is either 0 or 1, we can compress the 256 pixels of such a bitmap into 32 bytes.
To convert this to a single 0/1 label, we simply check if the entire bitmap is 0 or there are any pixels lit.</p>
<h2 id="the-binary-file-format">The binary file format<a hidden class="anchor" aria-hidden="true" href="#the-binary-file-format">#</a></h2>
<p>That&rsquo;s all we need. To populate our dataset, we generate six random vectors with coordinates uniformly chosen in \([-1,1]\),
canonicalize them, check for intersections, and compute the bitmap of the intersection curve.
Each sample is written to a binary file that has eleven 32-bit floats (44 bytes) for the canonicalized triangle coordinates
plus 32 bytes for the bitmap for each record, for a total of 76 bytes per record.
A simple binary format like this saves space and is easy and quick to read and write in both C++ and Python.</p>
<p>I multithreaded the generation of these binary data files to speed things up and collected the results in files
<code>triangles.000</code>, <code>triangles.001</code>, and so on, with each file containing 10,000 samples or 760,000 bytes.
Currently I have 90 of these files, giving us 900,000 samples to train with; later we&rsquo;ll augment our data set further.
All training samples are then concatenated into <code>triangles.dat</code>.
I also generated another 20,000 samples for the validation set, <code>triangles.val</code>.</p>
<p>Surprisingly, the simple random triangle generation leads to a data set that is very well balanced
between intersecting and non-intersecting triangles: of the 20,000 validation samples, 10,191 are positives.</p>
<p>With the input data set up, we can finally set up a model and start training!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://c-f-h.github.io/tags/math/">Math</a></li>
      <li><a href="https://c-f-h.github.io/tags/c&#43;&#43;/">C&#43;&#43;</a></li>
      <li><a href="https://c-f-h.github.io/tags/ml/">ML</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://c-f-h.github.io/post/refining-intersections/">
    <span class="title">« Prev</span>
    <br>
    <span>Getting Accurate Intersections with Gauss-Newton</span>
  </a>
  <a class="next" href="https://c-f-h.github.io/post/training-the-first-model/">
    <span class="title">Next »</span>
    <br>
    <span>Training the First Model</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://c-f-h.github.io/">cfh::blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
